<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>sinexy&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="sinexy&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="sinexy&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="Yunxin Bai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="sinexy&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sinexy&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS 接口与API设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/16/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2016-10-16T06:01:54.000Z" itemprop="datePublished">2016-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/16/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1/">iOS 接口与API设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在团队开发中，不可避免会将某些代码发布出来供其他同事使用，那么我们在编写接口时就会将其设计成易用复用的形式。需要参考 Objective-C 语言的编程范式，还需要了解各种可能遇到的陷阱。</p>
<p><strong>1. 用前缀避免命名空间冲突</strong><br>OC没有其他语言中内置的命名空间机制，所以我们在命名的时候要设法避免潜在的命名冲突，否则很容易重名。如果发生命名冲突，程序的链接过程就会出错，因为其中出现了重复符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _OBJC_METACLASS_$_MyClass in:</span><br><span class="line">    build/something.o</span><br><span class="line">    build/something._else.o</span><br><span class="line">duplicate symbol _OBJC_CLASS_$_MyClass in:</span><br><span class="line">    build/something.o</span><br><span class="line">    build/something._else.o</span><br></pre></td></tr></table></figure>
<p>错误原因在于，两份代码都各自实现了名为<code>MyClass</code>的类，这导致所对应的类符号和“元类”符号各定义了两次。避免此问题的唯一办法是变相实现命名空间，给所有名称都加上适当的前缀。</p>
<p><strong>2. 提供”全能初始化方法”</strong><br>所有对象都要初始化，在初始化时，有些对象可能无须开发者提供额外信息，但通过来说大部分对象在初始化时候都需要提供某些信息，如果对象不知道必要的信息，则无法完成其工作。<br>比如说，要编写一个学生类。其接口可以这样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface MyStudent: NSObject</span><br><span class="line">@property (nonatomic, copy, readonly) NSString name;</span><br><span class="line">@property (nonatomic, assign, readonly) int age;</span><br><span class="line">@property (nonatomic, assign, readonly) int number;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>我们把属性声明为只读，这样一来，外界就无法设置 MyStudent 对象的属性了。我们可以提供初始化方法以设置这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (MyStudent)initWithName:(NSString *)name age:(int)age andNumber:(int)number&#123;</span><br><span class="line">    if((self = [super init]))&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _age = age;</span><br><span class="line">        _number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 实现 description 方法</strong><br>调试时，经常需要打印并查看对象信息。一种办法是把对象的全部属性都一一输出，但常见的做法还是像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;object = %@&quot;, object);</span><br></pre></td></tr></table></figure>
<p>在构建需要打印到日志的字符串时，<code>object</code>对象会收到<code>description</code>消息，该方法所返回的描述信息将取代“格式字符串”(format string)里的 “%@”。比如说，<code>object</code>是个数组，用下列代码打印其信息时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *object = @[@&quot;A&quot;,&quot;B&quot;];</span><br><span class="line">NSLog(@&quot;object = %@&quot;, object);</span><br></pre></td></tr></table></figure>
<p>则会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = (&quot;A&quot;,&quot;B&quot;)</span><br></pre></td></tr></table></figure>
<p>然而，如果在自定义的类上这么做，那么输出的信息却是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = &lt;MyStudent: 0x7fd9a1600600&gt;</span><br></pre></td></tr></table></figure>
<p>这种日志对我们开发调试没啥帮助，所以我们要在自定义的类里面覆写<code>description</code>方法，输出更有用的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)description&#123;</span><br><span class="line">    return [NSStringstringWithFormat:@&quot;&lt;%@: %p, \&quot;%@ %@ %@\&quot;&gt;&quot;,</span><br><span class="line">            [self class], self, _name,_age,_number];</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 尽量使用不可变对象</strong></p>
<ul>
<li>尽量创建不可变的对象</li>
<li>如果某些属性仅用于对象内部修改，则在”class-continuation 分类”中将其由<code>readonly</code>属性拓展为<code>readwrite</code>属性。</li>
<li>不要把可变的<code>collection</code>作为属性公开，而应该提供相关方法，以此修改对象中的可变<code>collection</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/16/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1/" data-id="cm4p65ael0000fncacdexhrd8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-KVC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/11/KVC/" class="article-date">
  <time datetime="2016-09-11T02:07:19.000Z" itemprop="datePublished">2016-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/11/KVC/">KVC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>KVC 的概念</strong></p>
<p><code>KVC（Key-Value Coding）</code>是<code>Objective-C</code>中的一个强大机制，它允许通过字符串键来访问对象的属性。这种机制使得代码更具灵活性，尤其是在一些动态属性访问场景中，比如在与集合类型的对象（如<code>NSArray</code>、<code>NSDictionary</code>）交互时，或者在实现数据绑定等高级功能时非常有用。</p>
<p><code>KVC</code>的核心思想是通过键值对的方式来访问对象的属性，而不是直接通过<code>getter</code>和<code>setter</code>方法。</p>
<p>KVC在运行时使用动态消息传递的方式来完成这些操作，因此它对代码的灵活性和扩展性非常重要。</p>
<p>KVC常见的使用场景包括：</p>
<ul>
<li>动态修改对象的属性</li>
<li>在集合中查找对象</li>
<li>数据绑定</li>
<li>在某些特殊场景中替代传统的getter&#x2F;setter方法</li>
</ul>
<p><strong>KVC 的工作原理</strong><br><code>KVC</code>通过<code>NSObject</code>类的方法提供属性的动态访问。KVC工作时，调用的是<code>setValue:forKey:</code>和<code>valueForKey:</code>这两个方法。</p>
<ul>
<li><code>valueForKey:</code>：获取某个键（属性）对应的值。</li>
<li><code>setValue:forKey:</code>：设置某个键（属性）对应的值。</li>
</ul>
<p>这些方法会被动态地映射到相应的<code>getter</code>和<code>setter</code>方法，因此我们不需要显式地调用<code>setName:</code>或<code>name</code>这样的<code>getter</code>和<code>setter</code>，而是可以通过键来访问和设置属性值。</p>
<p><strong>KVC 的基本使用</strong></p>
<ol>
<li><p>获取值（valueForKey:）<br>使用<code>valueForKey:</code>方法来访问对象的属性值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *name = [person valueForKey:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>
<p>这里的<code>name</code>是属性的键（通常是属性名）。<code>KVC</code>会根据键查找相应的<code>getter</code>方法，并返回值。</p>
</li>
<li><p>设置值（setValue:forKey:）<br>使用<code>setValue:forKey:</code>方法来修改对象的属性值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person setValue:@&quot;John&quot; forKey:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>
<p>这个方法会调用相应的<code>setter</code>方法来设置<code>name</code>属性。</p>
</li>
<li><p>嵌套键路径<br><code>KVC</code>还支持嵌套键路径，允许你访问对象的嵌套属性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *city = [person valueForKeyPath:@&quot;address.city&quot;];</span><br></pre></td></tr></table></figure>
<p>这里，<code>address</code>是一个<code>Person</code>对象的属性，而<code>city</code>是<code>address</code>属性的属性。<code>KVC</code>会自动递归地解析这个路径并返回对应的值。</p>
</li>
</ol>
<p><strong>KVC 常见的操作</strong></p>
<ol>
<li><p>设置多个属性值（setValuesForKeysWithDictionary:）<br><code>KVC</code>允许你通过字典一次性设置多个属性值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict = @&#123;@&quot;name&quot;: @&quot;John&quot;, @&quot;age&quot;: @30&#125;;</span><br><span class="line">[person setValuesForKeysWithDictionary:dict];</span><br></pre></td></tr></table></figure>
<p>这个方法会将字典中的键值对映射到对象的属性中。</p>
</li>
<li><p>键值验证（validateValue:forKey:）<br><code>KVC</code>允许你在设置值之前对值进行验证。你可以实现<code>validateValue:forKey:</code>方法来确保属性值的合法性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateName:(id *)ioValue error:(NSError **)outError &#123;</span><br><span class="line">    NSString *name = *ioValue;</span><br><span class="line">    if (name.length == 0) &#123;</span><br><span class="line">        if (outError) &#123;</span><br><span class="line">            *outError = [NSError errorWithDomain:@&quot;MyDomain&quot; code:100 userInfo:@&#123;NSLocalizedDescriptionKey: @&quot;Name cannot be empty&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在<code>setValue:forKey:</code>方法调用时会被触发，确保属性值的正确性。</p>
</li>
<li><p>访问数组和字典的元素<br><code>KVC</code>允许你使用键来访问数组和字典中的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&#123;@&quot;name&quot;: @&quot;John&quot;&#125;, @&#123;@&quot;name&quot;: @&quot;Alice&quot;&#125;];</span><br><span class="line">NSString *firstName = [array valueForKeyPath:@&quot;name[0]&quot;];  // 访问第一个元素的&#x27;name&#x27;</span><br></pre></td></tr></table></figure>
<p>你可以使用类似于路径的语法来访问数组或字典中的元素。</p>
</li>
</ol>
<p><strong>KVC的优势和不足</strong><br>优势：</p>
<ul>
<li>动态访问属性：不需要显式地调用<code>getter/setter</code>方法，可以通过键值的方式动态访问。</li>
<li>简化代码：特别是在处理集合对象或复杂的嵌套对象时，<code>KVC</code>可以显著减少代码量。</li>
<li>与集合类型兼容：<code>KVC</code>特别适用于<code>NSArray</code>、<code>NSDictionary</code>等集合类型，可以通过键动态访问集合中的元素或属性。</li>
</ul>
<p>不足：</p>
<ul>
<li>属性必须是<code>KVC</code>兼容的：<code>KVC</code>只能访问遵循<code>KVC</code>约定的属性。这意味着属性需要有对应的<code>getter</code>和<code>setter</code>方法。如果某个属性没有这些方法，<code>KVC</code>将无法访问。</li>
<li>不适用于私有变量：<code>KVC</code>默认只操作公开的属性，无法直接访问私有实例变量。如果想要访问私有变量，可以通过<code>valueForKey:</code>来实现，但是需要手动为这些变量提供相应的<code>getter</code>和<code>setter</code>。</li>
<li>动态类型限制：<code>KVC</code>通过动态消息传递机制实现属性的访问，所以如果你在访问过程中修改了对象的结构（比如在运行时移除或添加某些属性），<code>KVC</code>可能会导致不稳定的行为。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/11/KVC/" data-id="cm4p4n62l00007kca6oas4t38" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-KVO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/07/KVO/" class="article-date">
  <time datetime="2016-08-07T13:27:32.000Z" itemprop="datePublished">2016-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/07/KVO/">KVO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>KVO 的概念</strong><br>KVO（Key-Value Observing）是 iOS 开发中一个强大的机制，允许对象观察其他对象的属性变化。在实现数据绑定、视图更新和响应数据变化时非常有用。</p>
<p>KVO是一种基于观察者模式的机制，它允许对象观察某个属性的变化，并在变化时收到通知。被观察的属性必须是KVC（Key-Value Coding）兼容的，这意味着属性需要通过键值访问。<br><strong>KVO 的工作原理</strong><br>当你为一个对象的属性注册为观察者时，iOS底层会动态地生成一个对象的子类（通过Objective-C运行时），并重写属性的setter方法。这个setter方法会在属性发生变化时通知所有的观察者。</p>
<p>观察者通过以下方法接收变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath </span><br><span class="line">                      ofObject:(id)object </span><br><span class="line">                        change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change </span><br><span class="line">                       context:(void *)context;</span><br></pre></td></tr></table></figure>

<p><strong>KVO 的使用步骤</strong></p>
<ol>
<li>添加观察者<br>使用addObserver:forKeyPath:options:context:方法为某个对象的属性添加观察者。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self </span><br><span class="line">              forKeyPath:@&quot;name&quot; </span><br><span class="line">                 options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld </span><br><span class="line">                 context:nil];</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>observer：观察者对象。</li>
<li>keyPath：需要观察的属性路径。</li>
<li>options：指定需要的变化信息（如新值、旧值等）。</li>
<li>context：上下文指针，可以传递额外的信息。</li>
</ul>
<ol start="2">
<li>实现回调方法<br>当被观察属性的值变化时，observeValueForKeyPath:ofObject:change:context:方法会被调用：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath </span><br><span class="line">                      ofObject:(id)object </span><br><span class="line">                        change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change </span><br><span class="line">                       context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;旧值: %@, 新值: %@&quot;, change[NSKeyValueChangeOldKey], change[NSKeyValueChangeNewKey]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>移除观察者<br>在不需要观察时，记得移除观察者，避免内存泄漏或崩溃：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>常见KVO选项</li>
</ol>
<ul>
<li><code>NSKeyValueObservingOptionNew：</code> 回调中包含新值。</li>
<li><code>NSKeyValueObservingOptionOld：</code> 回调中包含旧值。</li>
<li><code>NSKeyValueObservingOptionInitial：</code> 立即收到初始值的通知。</li>
<li><code>NSKeyValueObservingOptionPrior：</code> 在值变化前后都会收到通知。</li>
</ul>
<p><strong>注意事项和最佳实践</strong></p>
<ol>
<li>移除观察者</li>
</ol>
<ul>
<li>在对象释放之前，必须移除所有观察者，否则会导致崩溃。</li>
<li>在<code>dealloc</code>中确保移除所有观察者。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>避免重复添加观察者</li>
</ol>
<ul>
<li>重复添加观察者会导致多次回调，容易引发bug。</li>
</ul>
<ol start="3">
<li>线程安全</li>
</ol>
<ul>
<li>如果被观察的属性在多线程环境下被修改，可能会导致不一致或崩溃。可以使用同步锁或<code>@synchronized</code>确保线程安全。</li>
</ul>
<ol start="4">
<li>只能观察KVC兼容属性</li>
</ol>
<ul>
<li>直接使用<code>@property</code>声明的属性是<code>KVC</code>兼容的，动态添加的变量（如ivar）不支持<code>KVO</code>。</li>
</ul>
<ol start="5">
<li>使用上下文来区分观察者</li>
</ol>
<ul>
<li>如果同一个类中观察了多个属性，可以使用<code>context</code>参数区分不同的观察。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void *NameContext = &amp;NameContext;</span><br><span class="line"></span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:... context:NameContext];</span><br></pre></td></tr></table></figure>
<p>在回调中检查上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (context == NameContext) &#123;</span><br><span class="line">    // 处理 name 的变化</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>KVO的局限性</li>
</ol>
<ul>
<li>容易出错：忘记移除观察者可能导致崩溃。</li>
<li>调试困难：错误可能隐藏在底层动态生成的代码中。</li>
<li>性能问题：KVO在观察大量属性时可能导致性能下降。</li>
<li>代码复杂性：对复杂属性依赖的观察管理不便。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/07/KVO/" data-id="cm4p2kc2t0000wocaawe0c26n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RunLoop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/RunLoop/" class="article-date">
  <time datetime="2016-07-06T06:18:56.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/RunLoop/">RunLoop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>RunLoop 的概念</strong><br>一般来讲，一个线程一次只能执行一个任务，执行完之后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，就需要一个 RunLoop 对象。</p>
<p>实现这种模型的关键带你在于：如果管理事件&#x2F;消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部“接受消息-&gt;等待-&gt;处理”的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p><strong>RunLoop 与线程的关系</strong><br>首先，iOS 开发中能遇到两个线程对象：pthread_t 和 NSThread。苹果不允许直接创建  RunLoop，它只是提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code>和<code>CFRunLoopGetCurrent()</code>。这两个函数内部的逻辑大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 全局的 Dictionary，key 是 pthread_t，value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">// 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line">// 获取一个 pthread 对应的 RunLoop</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread)&#123;</span><br><span class="line">	OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">	</span><br><span class="line">	if(!loopsLook) &#123;</span><br><span class="line">		// 第一次进入时，初始化全局 Dic，并先为主线程创建一个  RunLoop。</span><br><span class="line">		loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">		CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">		CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mianLoop);</span><br><span class="line">	&#125;</span><br><span class="line">	// 直接从 Dictionary 里获取。</span><br><span class="line">	CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread);</span><br><span class="line">	if (!loop) &#123;</span><br><span class="line">		// 取不到时，创建一个</span><br><span class="line">		loop = _CFRunLoopCreate();</span><br><span class="line">		CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">		// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop</span><br><span class="line">		_CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">	&#125;</span><br><span class="line">	OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">	return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存再一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<p><strong>RunLoop 对外的接口</strong><br>在 CoreFoundation 里面关于 RunLoop 有5个类：</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source&#x2F;Timer&#x2F;Observer。每次调用 RunLoop的主函数时，只能指定其中一个 Mode，这个 Mode 被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source&#x2F;Timer&#x2F;Observer，让其互不影响。</p>
<p>CFRunLoopSourceRef 是事件产生的地方。Source 有两个版本：Source0和 source1.</p>
<ul>
<li>Source0 只包含了一个回调(函数指针)，它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop)来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是 toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。</p>
<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接收到这个变化。可以管着的时间点有以下几个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 Source&#x2F;Timer&#x2F;Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/RunLoop/" data-id="cm4p02l8v0004xdca919f5hlg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Objective-C-之消息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/03/Objective-C-%E4%B9%8B%E6%B6%88%E6%81%AF/" class="article-date">
  <time datetime="2016-06-03T02:15:16.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/Objective-C-%E4%B9%8B%E6%B6%88%E6%81%AF/">Objective-C 之消息机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>初学 Objective-C 时， 不觉得 <code>[object doSomething]</code> 与 <code>doSomething()</code> 有什么不一样，最多是写法看起来奇葩一点。随着了解的深入，渐渐觉得 Runtime 黑魔法简直不要太好用。</p>
<p>有任何不对的地方，还望大家批评指正。</p>
<h4 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h4><p>调用对象的方法，是再日常不过的操作。其他语言叫做方法调用，在 Objective-C 中叫做“消息传递”。消息有“名称”(name)或“选择子”(selector)，可以接受参数，也可能有返回值。</p>
<p>非动态语言在编译时期就能决定运行时应该调用的函数，而“动态绑定”是在运行期来决定到底该调用哪个方法，这样我们就可以在程序运行时改变其真实调用的方法，这些特性使得 Objective-C 成为一门真正的动态语言。</p>
<p>我们先来了解一下基本概念：</p>
<p><strong>SEL</strong>: 定义表示方法选择器的不透明类型。方法选择器用于表示运行时方法的名称。方法选择器是已使用Objective-C运行时注册（或“映射”）的C字符串。加载类时，编译器生成的选择器将由运行时自动映射。</p>
<p>可以这么理解，Objective-C 在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的编号，他的行为基本可以等同 C 语言中的函数指针，但 Objective-C 不能直接使用函数指针，只能通过<code>@selector</code>来取。<br>下面代码可能更清楚:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL sel = @selector(method);</span><br></pre></td></tr></table></figure>

<p>其实 SEL 的与类无关，只要方法名相同，SEL 就是一样的。<br>A 类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)print</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;打印 A&quot;);</span><br><span class="line">    SEL selA = @selector(print);</span><br><span class="line">    NSLog(@&quot;%p&quot;,selA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>B 类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)print</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;打印 B&quot;);</span><br><span class="line">    SEL selB = @selector(print);</span><br><span class="line">    NSLog(@&quot;%p&quot;,selB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>控制器中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassA *classA = [ClassA new];</span><br><span class="line">SEL selA = @selector(print);</span><br><span class="line">[classA print];</span><br><span class="line">ClassB *classB = [ClassB new];</span><br><span class="line">SEL selB = @selector(print);</span><br><span class="line">[classB print];</span><br><span class="line">NSLog(@&quot;%p-----%p&quot;,selA, selB);</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">打印 A</span><br><span class="line">0x10d8ceade</span><br><span class="line">打印 B</span><br><span class="line">0x10d8ceade</span><br><span class="line">0x10d8ceade-----0x10d8ceade</span><br></pre></td></tr></table></figure>
<p>所以在 Objective-C 中，同一个类不能存在2个同名方法，即使参数类型不同也不行，没有方法重载一说。</p>
<p><strong>IMP</strong>:指向方法实现开始的指针。其定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>此数据类型是指向实现该方法的函数的开头的指针。此函数使用为当前CPU体系结构实现的标准C调用约定。第一个参数是指向<code>self</code>的指针（即，此类的特定实例的内存，或者，对于类方法，指向元类的指针）。第二个参数是方法选择器。方法参数接在后面。</p>
<p>前面介绍的<code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的。每个方法对应唯一的<code>SEL</code>，因此通过<code>SEL</code>可以快速准确地获得其所对应的<code>IMP</code>。拿到了 <code>IMP</code>就可以执行对应的方法了。</p>
<p><strong>Method</strong>:表示类定义中的方法。其定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">		SEL method_name;</span><br><span class="line">		char *method_types;</span><br><span class="line">		IMP method_imp;</span><br><span class="line">	&#125; method_list[1];		/* variable length structure */</span><br></pre></td></tr></table></figure>
<p>方法的结构体中包含了一个<code>SEL</code>和<code>IMP</code>，实际上相当于把 <code>SEL</code> 和 <code>IMP</code> 建立了一个映射关系，对应起来了。</p>
<p>在 Objective-C 中，给对象发送消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassA *classA = [ClassA new];</span><br><span class="line">[classA print];</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(classA, print);</span><br></pre></td></tr></table></figure>
<p>其原型是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL cmd, ...)</span><br></pre></td></tr></table></figure>

<p><code>classA</code> 叫做“接收者”(receiver), <code>print</code> 叫做“选择子”(selector)。<br><code>objc_msgSend</code> 函数会依据 <code>self</code>和<code>SEL</code>来调用适当的方法。</p>
<p>具体操作如下：</p>
<p>先在接收者所属的类中搜寻其“方法列表”(list of methods)，如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，那就站着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行“消息转发”(message forwarding)操作。</p>
<h5 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h5><p>由于 Objective-C 的动态性，编译时期不能确定某类是否能执行某个方法(运行期可以向类中添加方法)。</p>
<p>消息转发分为两大阶段。第一阶段先征询接收者所属的类，看其是否能动态添加方法，已处理当前这个“未知的选择子”，这叫做“动态方法解析”(dynamic method resolution)。第二个阶段设计“完整的消息转发机制”。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又分为两小步：首先，请接收者看看有没有其它对象能处理这条消息。若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一切如常。若没有，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到 <code>NSInvocation</code>对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。</p>
<p><strong>动态方法解析</strong><br>对象在收到无法解读的消息后，首先将调用其所遇类的下列类方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure>
<p>该方法的参数就是那个未知的选择子，其返回值为<code>Boolean</code>类型，表示这个类是否能新增一个实例方法用以处理此选择子。在继续往下执行转发机制之前，本类有机会新增一个处理此选择子的方法。如果尚未实现的方法是类方法，那么就会使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)selector</span><br></pre></td></tr></table></figure>
<p>使用这种办法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插在类中就可以了。此方法常用来实现<code>@dynamic 属性</code>。</p>
<p><strong>备援接收者</strong><br>当前接收者还有第二次机会能处理未知的选择子，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)selector</span><br></pre></td></tr></table></figure>
<p>方法参数代表未知的选择子，若当前接收者能找到备援对象，则将其返回，若找不到，就返回 nil。通过此方法，我们可以用“组合”(composition)来模拟出“多重继承”(multiple inheritance)的某些特性。注意，我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</p>
<p><strong>完整的消息转发</strong><br>如果转发算法已经来到这一步的话，那么唯一能做的就是启用完整的消息转发机制了。首先创建<code>NSInvocation</code>对象，把与尚未处理的那条消息有关的全部细节都封于其中。词对象包含选择子、目标(target)及参数。在触发<code>NSInvocation</code>对象时，“消息派发系统”(message-dispatch system)将亲自出马，把消息指派给目标对象。<br>此步骤会调用下列方法来转发消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation*)invocation</span><br></pre></td></tr></table></figure>
<p>这个方法可以实现得很简单：只需改变调用目标，使消息在新目标上得以调用即可。然而这样实现出来的方法与“备援接收者”方案所实现的方法等效，所以很少有人采用这么简单的实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择子，等等。<br>实现此方法时，若发现某调用操作不应该由本类处理，则需要调用超类的同名方法。这样的话，继承体系中的每个类都有机会处理此调用请求，直到<code>NSObject</code>。如果最后调用了 NSObject 类的方法，那么该方法还会继而调用<code>doesNotRecognizeSelector:</code>以抛出异常，此异常表名选择子最终最能得到处理。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://developer.apple.com/documentation/objectivec/">Apple Documentation</a><br><a href="https://opensource.apple.com/tarballs/objc4/">Source Browser</a><br><a href="http://southpeak.github.io/2014/11/03/objective-c-runtime-3/">Objective-C Runtime 运行时之三：方法与消息</a><br><a href="http://limite.me/blog/2015/01/07/objective-czhong-de-selectorhe-sel/">Objective-C中的Selector和SEL</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/03/Objective-C-%E4%B9%8B%E6%B6%88%E6%81%AF/" data-id="cm4p02l8u0002xdcacyq05aw2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Objective-C-声明变量的两种常见方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/06/Objective-C-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2016-05-06T04:11:21.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/Objective-C-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/">Objective-C 声明变量的两种常见方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>昨天突然想起前同事问过的一个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	NSString *_aString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *aString;</span><br></pre></td></tr></table></figure>
<p>这两种写法有什么区别？<br>正好在一个开发群里，也看到过类似问题，索性写一段话来表达一下自己的看法。有任何不对的地方，还望大家批评指正。</p>
<h4 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h4><p>声明在<code>&#123;&#125;</code>中的，叫做成员变量；而用 <code>@property</code>修饰的，顾名思义叫做属性。</p>
<p>先说区别：</p>
<ul>
<li><p>在’{}’中声明的成员变量，级别是<code>protected</code>的。简单来说就是子类和当前类可以使用这个成员变量，其他类不可以。而用‘@property’声明的变量,级别是<code>public</code>，可以在当前类或者其他类中被访问。</p>
</li>
<li><p>在’{}’中声明成员变量，使用变量名进行访问；‘@property’声明的变量，使用_变量名(在变量名前加一个下划线),或者self.变量名进行访问。</p>
</li>
<li><p>在’{}’中声明成员变量，直接访问保存实例变量的那块内存，没有调用 set&#x2F;get 方法，不走“方法派发”(method dispatch)，所以要更快。</p>
</li>
<li><p>在’{}’中声明成员变量，不走 set 方法，自然就没有一堆属性特质，那也就绕过了内存管理语义。</p>
</li>
<li><p>在’{}’中声明成员变量，不会触发 KVO(Key-Value Observing)。</p>
</li>
</ul>
<p>其实，对于写 Java 或者 C++的同学来说，在’{}’中声明成员变量这种写法再正常不过，而 Objective-C 代码通常不这样写。因为这种写法：</p>
<blockquote>
<p>对象布局在编译期(compile time)就已经固定了。</p>
</blockquote>
<p>眼神好的同学应该注意到“编译期”这三个字。想想看，Objective-C 的一项重要特性——运行时。在某个类中动态添加属性是不是很高级？</p>
<blockquote>
<p>只要碰到访问 _aString 变量的代码，编译器就把其替换为“偏移量”(offset)，这个偏移量是“硬编码”(hardcode)，表示该变量存放对象的内存区域的其实地址有多远。这样做看起来没什么问题，但是如果又加了一个实例变量，那就麻烦了。</p>
</blockquote>
<p>当然，这个问题苹果工程师已经解决了，他们的做法是把实例变量当做一种存储偏移量所用的“特殊变量”(special variable)，交由“类对象”(class object)保管。偏移量会在运行期查找，如果类的定义变了，那么存储的偏移量也就变了，无论何时访问实例变量，总能使用正确的偏移量。</p>
<p>而另一个解决方案就是使用‘@property’。其实</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) NSString *aString;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	NSString *_aString;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)aString;</span><br><span class="line">- (void)setAString:(NSString *)aString;</span><br></pre></td></tr></table></figure>

<p>想要访问属性，可以使用 _aString 或者 self.aString。写 Java 的同学又开心了，因为这个”.属性名”和 Java 的中写看起来一样。其实，在 Objective-C 中，没有”点语法”，这是编译器搞出来的。在使用  self.aString 时，编译器会将其转换为对应的存取方法调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AObject *aObject = [AObject new];</span><br><span class="line">aObject.aString = @&quot;一堆文字&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;,aObject.aString);  // 打印结果我不写</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AObject *aObject = [AObject new];</span><br><span class="line">[aObject setAString:@&quot;一堆文字&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[aObject aString]);</span><br></pre></td></tr></table></figure>
<p>如果<code>@property</code>只有这点作用，存在的意义就不大了。所以，属性特质就出现了。(因果逻辑 doge)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readwrite, copy) NSString *aString;</span><br></pre></td></tr></table></figure>

<p>说到属性特质，我们可以又扯到 Objective-C 的内存管理去，所以我们下次再聊。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li>Effective+Objective-C+2.0++编写高质量iOS与OS+X代码的52个有效方法</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/06/Objective-C-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/" data-id="cm4p02l8u0003xdca40cu1poa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Objective-C Runtime 之 Class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/Objective-C%20Runtime%20%E4%B9%8B%20Class/" class="article-date">
  <time datetime="2016-04-15T03:11:21.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/Objective-C%20Runtime%20%E4%B9%8B%20Class/">Objective-C Runtime 之 Class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>与 C 等面向过程的语言不同，用 Objective-C 、C++ 等面向对象语言编程时，<strong>“对象”(object)<strong>就是“基本构造单元”，开发者使用对象来传递、存储数据。在对象之间传递数据并执行操作的过程叫做</strong>消息传递</strong>或者<strong>方法调用</strong>。</p>
<p>Objective-C 是 C 的超集。所有 C 的代码都可以直接放在 Objective-C 程序里经过编译。而且 Objective-C 的 OOP 就是使用 C 结构体模拟的。</p>
<p>既然说到了 OO 编程，那就先聊聊 Objective-C 中的类吧，源码在<a href="https://opensource.apple.com/tarballs/objc4/">这里</a>可以看到。</p>
<p>有任何不对的地方，还望大家批评指正。</p>
<h4 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h4><p><code>Class</code> 是一个指向 <code>objc_class</code>结构体的指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p><code>objc_class</code>结构体的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">	struct objc_class *isa;	</span><br><span class="line">	struct objc_class *super_class;	</span><br><span class="line">	const char *name;		</span><br><span class="line">	long version;</span><br><span class="line">	long info;</span><br><span class="line">	long instance_size;</span><br><span class="line">	struct objc_ivar_list *ivars;</span><br><span class="line"></span><br><span class="line">#if defined(Release3CompatibilityBuild)</span><br><span class="line">	struct objc_method_list *methods;</span><br><span class="line">#else</span><br><span class="line">	struct objc_method_list **methodLists;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	struct objc_cache *cache;</span><br><span class="line"> 	struct objc_protocol_list *protocols;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面依次了解一下各成员变量的意义：</p>
<p><code>isa</code>: 大名鼎鼎的 isa 指针，相信面试中大多数人都遇到过这个问题，说说什么 isa<br>描述 Objective-C 对象所用的数据结构在 runtime.h 中可以看到，id 类型本身也定义在这里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;  *id;</span><br></pre></td></tr></table></figure>
<p>其实顾名思义，is a ，该变量定义了对象所属的类，该对象属于哪个类，isa 就指向那个类，<img src="https://raw.githubusercontent.com/WiInputMethod/interview/master/img/ios-runtime-class.png" alt="这张图片"><br>这张图早已说明了一切：<br>类中的 super_class 指针用来追溯整个继承链。isa 指针找到其所属的类。</p>
<p><code>super_class</code>: 指向该类的父类，如果该类已是根类，则为 NULL<br><code>name</code>: 类名<br><code>version</code>: 版本信息<br><code>info</code>: 类信息<br><code>instance_size</code>: 实例大小<br><code>ivars</code>: 成员变量地址列表，还记得之前说过的声明成员变量的两种常见方式么，里面提到把成员变量当做一种储存偏移量的特殊变量，交由类对象保管。就保管在这里呢<br><code>methodLists</code>: 方法列表。<br><code>cache</code>: 方法缓存。<br><code>protocols</code>: 协议列表。</p>
<h5 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h5><p>所有的类自身也是一个对象。元类存储着一个类的所有类方法。元类也是一个类，它的<code>isa</code>指针，指向基类的元类，基类的元类的<code>isa</code>指针指向它自己，这就形成了一个闭环。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li><a href="http://chachatelier.fr/programmation/fichiers/cpp-objc-en.pdf">From C++ to Objective-C</a></li>
<li><a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/">Objective-C Runtime 运行时之一：类与对象</a></li>
<li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/#Class">Objective-C Runtime</a></li>
<li>《Effective+Objective-C+2.0++编写高质量iOS与OS+X代码的52个有效方法》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/15/Objective-C%20Runtime%20%E4%B9%8B%20Class/" data-id="cm4p02l8r0001xdcag3ag7tj2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS的内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/08/iOS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2016-03-08T10:26:29.000Z" itemprop="datePublished">2016-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/08/iOS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Objective-C 的内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>iOS 内存管理相关的内容其实已经一大堆了，为了加强理解，写了这篇读书笔记。有任何不对的地方，还望大家批评指正。</p>
<h4 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h4><h5 id="C-语言内存模型"><a href="#C-语言内存模型" class="headerlink" title="C 语言内存模型"></a>C 语言内存模型</h5><p>说 Objective-C 的内存管理之前，可以了解一下 C 的内存模型</p>
<p>内存分区有哪些？<br>栈、全局(静态)区、堆、字符串常量区</p>
<ul>
<li><p>栈(stack):C语言函数内部变量包括局部变量和形式参数等。在进入函数的时候自动分配，在离开函数时自动清除的变量存储区。</p>
</li>
<li><p>全局&#x2F;静态区(global&#x2F;static):存放全局变量和静态变量的存储区。全局变量也称为外部变量，它是在函数外部定义的变量。全局变量是所有函数的公用变量，整个程序中任何一个函数都可以任意地调用它。静态变量和全局变量被分配到同一块内存中，静态局部变量只限于在定义处的函数使用，但是离开函数后数值一直保留，直到程序退出。</p>
</li>
<li><p>堆(heap):由调用malloc函数分配的内存块，一般每一次malloc函数分配的内存块，最后都要对应调用一次free函数释放这个内存块。如果程序员没有释放掉，那么在程序结束后，操作系统会自动释放。</p>
</li>
<li><p>常量储存区:就是存放程序内所有字符串常量的内存区域，这个内存区域上存储的内容不允许修改，直到程序退出为止。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;  // 全局</span><br><span class="line">char *p;    // 全局</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int b;  // 栈</span><br><span class="line">    char s[] = &quot;abc&quot;;   // 栈</span><br><span class="line">    char *p1;   // 栈</span><br><span class="line">    char *p2 = &quot;123456&quot;;    // 123456/0在常量区，p2在栈上</span><br><span class="line">    static int c = 0;   // 全局</span><br><span class="line">    p = (char *)malloc(10);    // 堆</span><br><span class="line">    p1 = (char *)malloc(20);    // 堆</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别:</strong></p>
<ol>
<li>栈由系统自动分配，不用担心释放问题；堆需要程序员自己申请，那就需要程序员来释放。</li>
<li>栈由系统自动分配，速度就比较快；堆是<code>new</code>或者<code>malloc</code>出来，一般速度比较慢，而且容易产生内存碎片（话说 OC 中的<code>allocWithZone:</code>中这个’zone’，貌似就是减少碎片产生的存在）。</li>
<li>栈是一块连续的内存区域，内存大小比较小；堆是不连续的，比较大。</li>
</ol>
<h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>先来说说垃圾回收机制。如上所说，虽然栈中内存会自动释放，但堆中的已分配内存需要我们自己来释放。自己来管理内存的话，释放时机的把握就很重要了。如果释放早了，还有其他地方在使用这块内存中的对象，那就形成了垂悬指针。或者本来这块内存中的对象已经没地方用了，你又没释放，本来就很着急的内存空间，怕是要溢出了。所以，垃圾回收机制就是解决这个问题的。</p>
<p>传统算法：</p>
<ul>
<li>引用计数(Reference Counting)算法</li>
<li>标记-清除(Mark-Sweep)算法</li>
<li>复制(Copying)算法</li>
</ul>
<p>标记-清除算法：简单来说，就是轮询所有对象，把被引用的对象标记起来，轮询结束后就清除所有没有被标记的对象。</p>
<p>复制算法：把堆空间分成A、B两份，每次只使用其中之一。假设先使用 A 区域，当系统认为需要回收垃圾时，把所有正在被使用的对象复制到 B 区域。然后清空 A。到下一次需要收集时，再在 B 中正在被使用的对象复制到 A，然后清空 B。</p>
<p>Objective-C 中的内存管理用的就是引用计数：每次有对象被引用，那么对象的引用计数就+1，当你不再引用这个对象时，就告诉对象，让他引用计数-1。当引用计数为0时，就释放该对象。</p>
<p>有这样一个口诀：</p>
<ul>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<h5 id="内存管理的具体实现"><a href="#内存管理的具体实现" class="headerlink" title="内存管理的具体实现"></a>内存管理的具体实现</h5><p>以一个对象的生成、持有、释放、销毁为一个完整的生命周期来探讨苹果的实现。<br>通过 GNUstep 源码中的 <a href="https://github.com/gnustep/libs-base/blob/master/Source/NSObject.m">NSObject</a> 类来学习。</p>
<p><strong>生成</strong><br>首先，看<code>alloc</code>方法。这是一个类方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+ (id) alloc</span><br><span class="line">&#123;</span><br><span class="line">  return [self allocWithZone: NSDefaultMallocZone()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id) allocWithZone: (NSZone*)z</span><br><span class="line">&#123;</span><br><span class="line">  return NSAllocateObject(self, 0, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSAllocateObject(Class aClass, NSUInteger extraBytes, NSZone *zone)</span><br><span class="line">&#123;</span><br><span class="line">  id	new;</span><br><span class="line">#ifdef OBJC_CAP_ARC</span><br><span class="line">  if ((new = class_createInstance(aClass, extraBytes)) != nil)</span><br><span class="line">    &#123;</span><br><span class="line">      AADD(aClass, new);</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">  int	size;</span><br><span class="line">  NSCAssert((!class_isMetaClass(aClass)), @&quot;Bad class for new object&quot;);</span><br><span class="line">  size = class_getInstanceSize(aClass) + extraBytes + sizeof(struct obj_layout);</span><br><span class="line">  if (zone == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      zone = NSDefaultMallocZone();</span><br><span class="line">    &#125;</span><br><span class="line">  new = NSZoneMalloc(zone, size);</span><br><span class="line">  if (new != nil)</span><br><span class="line">    &#123;</span><br><span class="line">      memset (new, 0, size);</span><br><span class="line">      new = (id)&amp;((obj)new)[1];</span><br><span class="line">      object_setClass(new, aClass);</span><br><span class="line">      AADD(aClass, new);</span><br><span class="line">    &#125;</span><br><span class="line">  if (0 == cxx_construct)</span><br><span class="line">    &#123;</span><br><span class="line">      cxx_construct = sel_registerName(&quot;.cxx_construct&quot;);</span><br><span class="line">      cxx_destruct = sel_registerName(&quot;.cxx_destruct&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  callCXXConstructors(aClass, new);</span><br><span class="line">#endif</span><br><span class="line">  return new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>obj_layout</code>了没，他里面有个<code>retained</code>这就是用来存引用计数的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct obj_layout &#123;</span><br><span class="line"></span><br><span class="line">  char	padding[__BIGGEST_ALIGNMENT__ - ((UNP % __BIGGEST_ALIGNMENT__)</span><br><span class="line"></span><br><span class="line">    ? (UNP % __BIGGEST_ALIGNMENT__) : __BIGGEST_ALIGNMENT__)];</span><br><span class="line"></span><br><span class="line">  gsrefcount_t retained;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">typedef	struct obj_layout *obj;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实，说了这么多，就是想说，在创建对象的时候，有个保存引用计数的变量。感觉说了一堆废话…</p>
<p><strong>持有</strong><br>接下来，了解一下持有对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">- (id) retain</span><br><span class="line">&#123;</span><br><span class="line">  return retain_fast(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static id retain_fast(id anObject)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef SUPPORT_WEAK</span><br><span class="line">  if (objc_retain_fast_np)</span><br><span class="line">    &#123;</span><br><span class="line">      return objc_retain_fast_np(anObject);</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">#endif</span><br><span class="line">    &#123;</span><br><span class="line">      return objc_retain_fast_np_internal(anObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static id objc_retain_fast_np_internal(id anObject)</span><br><span class="line">&#123;</span><br><span class="line">  BOOL  tooFar = NO;</span><br><span class="line">#if	defined(GSATOMICREAD)</span><br><span class="line"></span><br><span class="line">  if (GSAtomicIncrement((gsatomic_t)&amp;(((obj)anObject)[-1].retained)) &gt; 0xfffffe)</span><br><span class="line">    &#123;</span><br><span class="line">      tooFar = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#else	/* GSATOMICREAD */</span><br><span class="line">  pthread_mutex_t *theLock = GSAllocationLockForObject(anObject);</span><br><span class="line">  pthread_mutex_lock(theLock);</span><br><span class="line">  if (((obj)anObject)[-1].retained &gt; 0xfffffe)</span><br><span class="line">    &#123;</span><br><span class="line">      tooFar = YES;</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      ((obj)anObject)[-1].retained++;</span><br><span class="line">    &#125;</span><br><span class="line">  pthread_mutex_unlock(theLock);</span><br><span class="line">#endif	/* GSATOMICREAD */</span><br><span class="line">  if (YES == tooFar)</span><br><span class="line">    &#123;</span><br><span class="line">      static NSHashTable        *overrun = nil;</span><br><span class="line">      [gnustep_global_lock lock];</span><br><span class="line">      if (nil == overrun)</span><br><span class="line">        &#123;</span><br><span class="line">          overrun = NSCreateHashTable(NSNonRetainedObjectHashCallBacks, 0);</span><br><span class="line">        &#125;</span><br><span class="line">      if (0 == NSHashGet(overrun, anObject))</span><br><span class="line">        &#123;</span><br><span class="line">          NSHashInsert(overrun, anObject);</span><br><span class="line">        &#125;</span><br><span class="line">      else</span><br><span class="line">        &#123;</span><br><span class="line">          tooFar = NO;</span><br><span class="line">        &#125;</span><br><span class="line">      [gnustep_global_lock lock];</span><br><span class="line">    	if (YES == tooFar)</span><br><span class="line">        &#123;</span><br><span class="line">          NSString      *base;</span><br><span class="line">			  base = [NSString stringWithFormat: @&quot;&lt;%s: %p&gt;&quot;,</span><br><span class="line">          class_getName([anObject class]), anObject];</span><br><span class="line">          [NSException raise: NSInternalInconsistencyException</span><br><span class="line">            format: @&quot;NSIncrementExtraRefCount() asked to increment too far&quot;</span><br><span class="line">            @&quot; for %@ - %@&quot;, base, anObject];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return anObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是在持有对象的时候，让对象的引用计数++。</p>
<p><strong>释放</strong><br>限于篇幅，释放就不贴代码了。就是每次调用的时候让对象的引用计数–。<br>这里 GNUstep 做了一个简单的容错，当引用计数&lt;0时，让其&#x3D;0。<br>当引用计数为0时，调用<code>[self dealloc]</code>方法，也就是销毁对象的方法。</p>
<p><strong>销毁</strong><br><code>dealloc</code>方法里面又调用了<code>NSDeallocateObject(self)</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">NSDeallocateObject(id anObject)</span><br><span class="line">&#123;</span><br><span class="line">  Class aClass = object_getClass(anObject);</span><br><span class="line">  if ((anObject != nil) &amp;&amp; !class_isMetaClass(aClass))</span><br><span class="line">    &#123;</span><br><span class="line">#ifndef OBJC_CAP_ARC</span><br><span class="line">      obj	o = &amp;((obj)anObject)[-1];</span><br><span class="line">      NSZone	*z = NSZoneFromPointer(o);</span><br><span class="line">#endif</span><br><span class="line">      (*finalize_imp)(anObject, finalize_sel);</span><br><span class="line">      AREM(aClass, (id)anObject);</span><br><span class="line">      if (NSZombieEnabled == YES)</span><br><span class="line">	&#123;</span><br><span class="line">#ifdef OBJC_CAP_ARC</span><br><span class="line">	  if (0 != zombieMap)</span><br><span class="line">	    &#123;</span><br><span class="line">              pthread_mutex_lock(&amp;allocationLock);</span><br><span class="line"></span><br><span class="line">	      NSMapInsert(zombieMap, (void*)anObject, (void*)aClass);</span><br><span class="line"></span><br><span class="line">              pthread_mutex_unlock(&amp;allocationLock);</span><br><span class="line">	    &#125;</span><br><span class="line">	  if (NSDeallocateZombies == YES)</span><br><span class="line">	    &#123;</span><br><span class="line">	      object_dispose(anObject);</span><br><span class="line">	    &#125;</span><br><span class="line">	  else</span><br><span class="line">	    &#123;</span><br><span class="line">	      object_setClass(anObject, zombieClass);</span><br><span class="line">	    &#125;</span><br><span class="line">#else</span><br><span class="line">	  GSMakeZombie(anObject, aClass);</span><br><span class="line">	  if (NSDeallocateZombies == YES)</span><br><span class="line">	    &#123;</span><br><span class="line">	      NSZoneFree(z, o);</span><br><span class="line">	    &#125;</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">      else</span><br><span class="line">	&#123;</span><br><span class="line">#ifdef OBJC_CAP_ARC</span><br><span class="line">	  object_dispose(anObject);</span><br><span class="line">#else</span><br><span class="line">	  object_setClass((id)anObject, (Class)(void*)0xdeadface);</span><br><span class="line">	  NSZoneFree(z, o);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这么一大堆就是销毁最开始<code>alloc</code>分配的内存。</p>
<p>以上就是一个对象完整的生命周期了。</p>
<h5 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h5><p>说到这个内存管理，autorelease 也需要了解一下。<br>autorelease 与作用域的概念很类似，当超出其作用范围时，销毁作用域里面的变量。<br>其步骤如下：</p>
<ol>
<li>生成并持有 NSAutoreleasePool 对象</li>
<li>调用已分配对象的 autorelease 实例方法</li>
<li>废弃 NSAutoreleasePool 对象</li>
</ol>
<p>有个很典型的例子：<br>在大量读入图片改变其尺寸时，图像文件读入到 NSData 对象，并从中生成 UIImage 对象，改变该对象尺寸后生成新的 UIImage 对象。这种情况下，就会大量产生 autorelease 对象。<br>在这种情况下，有必要在适当的地方生成、持有或废弃 NSAutoreleasePool 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 图片数量; i++)&#123;</span><br><span class="line">	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">	/**</span><br><span class="line">	 * 读入图像</span><br><span class="line">	 * 产生大量 autorelease 对象</span><br><span class="line">	 */</span><br><span class="line">	 [pool drain];	// autorelease 的对象被一起 release</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 Objective-C 的内存管理。其实无论 ARC 还是 MRC 都一样，区别就是 ARC 的情况下，编译器帮我们在合适的地方加入了 retain 和 release 操作。</p>
<h5 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h5><p>还记得上一篇讲声明成员变量的两种方式那篇文章么，其中在用<code>@property</code>这种方式的时候，可以指定该属性的所有权修饰符。<br>ARC 下常用的修饰符有4种：</p>
<ul>
<li>__autoreleasing</li>
<li>__strong</li>
<li>__unsafe_unretained</li>
<li>__weak</li>
</ul>
<p>是不是有点疑惑，和我们常用的不一样。别慌<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">文档</a>告诉我们该怎么用。</p>
<ul>
<li>assign 和 __unsafe_unretained 一样，表示非拥有关系。</li>
<li>copy 和 __strong 一样表示拥有关系，还多出来了 setter 上复制语义的通常行为。</li>
<li>retain 和 __strong 一样表示拥有关系。</li>
<li>strong 和 __strong 一样表示拥有关系。</li>
<li>weak 和 __weak 一样，表示非拥有关系。</li>
<li>unsafe_unretained 和 __unsafe_unretained 一样，表示非拥有关系。</li>
</ul>
<p><strong>__strong</strong><br>__strong是 id 类型和对象类型的默认修饰符。strong顾名思义”强引用”。超出其作用域时，强引用失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// objA 持有 对象 A 的强引用</span><br><span class="line">id __strong objA = [[NSObject alloc] init];   // 对象 A</span><br><span class="line">// objB 持有 对象 B 的强引用</span><br><span class="line">id __strong objB = [[NSObject alloc] init];   // 对象 B</span><br><span class="line">// objC 不持有任何对象</span><br><span class="line">id __strong objC = nil;</span><br><span class="line">/**</span><br><span class="line"> * objA 持有objB 对象的强引用</span><br><span class="line"> * 所以 原来由 objA 持有的对象A，强引用失效，对象A 的持有者不存在，所以废弃对象 A</span><br><span class="line"> * 此时，对象 B 的强引用变量变为 objA 和 objB。</span><br><span class="line"> */</span><br><span class="line">objA = objB;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * objC 持有objA 的对象 B 的强引用</span><br><span class="line"> * 此时，对象 B 的强引用变量变为 objA， objB 和 objC。</span><br><span class="line"> */</span><br><span class="line">objC = objA;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * objB 被赋值为 nil，不再持有原对象 B</span><br><span class="line"> * 此时，对象 B 的强引用变量变为 objA 和 objC。</span><br><span class="line"> */</span><br><span class="line">objB = nil;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * objA 被赋值为 nil，不再持有原对象 B</span><br><span class="line"> * 此时，对象 B 的强引用变量变为 objC。</span><br><span class="line"> */</span><br><span class="line">objA = nil;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * objC 被赋值为 nil，不再持有原对象 B</span><br><span class="line"> * 此时，对象 B 的强引用不存在，因此废弃对象 B</span><br><span class="line"> */</span><br><span class="line">objC = nil;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>__weak</strong><br>引用计数管理有个绕不开的问题就是循环引用，当对象 A 和对象 B 都互相持有对方，那他们的引用计数就永远不可能为0，那就不能被释放，导致内存泄露。所以内存泄露就是指应该被废弃的对象在超出其生命周期后继续存在。</p>
<p>__weak 除了能消除循环引用外， 还有一个优点就是当持有的对象被销毁是，此弱引用将自动失效且处于 被nil 复制的状态。</p>
<p>所有被 __weak 修饰的对象，都会被加入到自动释放池中。(每次访问该对象，都会注册到自动释放池，开销更大，所以在 block 外部使用 __weak修饰的对象打破循环引用后，在 block 内部改为用 __strong修饰，以节省开销)</p>
<p><strong>__unsafe_unretained</strong><br>__unsafe_unretained 和 __weak 很像，但是当对象被销毁后，再访问该对象会出现奔溃(悬垂指针)。所以一般来说，对象用 weak 修饰，标量类型由 assign 修饰。</p>
<p><strong>__autoreleasing</strong><br>这个类型和上述的 atuorelease 的作用一样，就是将被修饰的对象，放入自动释放池中。</p>
<p>Objective-C 的内存管理大概就是这么回事了吧。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">自动引用计数</a><br><a href="https://github.com/gnustep/libs-base/blob/master/Source/NSObject.m">GNUstep 中的 NSObject</a></li>
<li>《Objective-C 高级编程》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/08/iOS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="cm4p02l8y0006xdca5fvo2ao2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/03/hello-world/" class="article-date">
  <time datetime="2016-03-03T12:01:10.000Z" itemprop="datePublished">2016-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/03/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>终于弄一个写东西的地方，不过按我尿性，怕是基本不更新(doge</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/03/hello-world/" data-id="cm4p02l8w0005xdcagkcl36sd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/16/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1/">iOS 接口与API设计</a>
          </li>
        
          <li>
            <a href="/2016/09/11/KVC/">KVC</a>
          </li>
        
          <li>
            <a href="/2016/08/07/KVO/">KVO</a>
          </li>
        
          <li>
            <a href="/2016/07/06/RunLoop/">RunLoop</a>
          </li>
        
          <li>
            <a href="/2016/06/03/Objective-C-%E4%B9%8B%E6%B6%88%E6%81%AF/">Objective-C 之消息机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Yunxin Bai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
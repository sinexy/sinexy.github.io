<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>sinexy&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="sinexy&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="sinexy&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="Yunxin Bai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="sinexy&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sinexy&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-人月神话（六）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/19/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%85%AD%EF%BC%89/" class="article-date">
  <time datetime="2017-02-18T16:01:16.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%85%AD%EF%BC%89/">人月神话（六）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>沟通成本的增长：<br>团队规模与沟通的复杂度：**”沟通复杂度指数”**，即随着团队成员数量的增加，团队成员之间的沟通量呈指数增长。对于每一个新加入的成员，都会增加与其他成员沟通的需要和难度。<br>沟通成本的数学模型：假设团队有 n 名成员，那么在没有任何沟通工具的情况下，每个成员需要与其他 n-1 个成员沟通。因此，随着团队成员数量增加，沟通的总成本呈 O(n²) 增长。每增加一个人，增加的沟通负担是前者的倍数。</p>
</li>
<li><p>沟通的代价：<br>信息传递中的误解与错误：随着团队规模的扩大，信息在传递过程中容易发生误解。每个团队成员都有不同的背景、经验和理解方式，因此在信息传递的过程中，可能会有偏差或不准确的理解。<br>信息传递的层次结构：在较大的团队或项目中，信息的传递往往不是直接的，可能需要通过多个中介层次进行传递，进一步加大了信息失真和误解的风险。</p>
</li>
<li><p>减少沟通复杂度的策略：<br>小团队的优势：小团队比大团队更加高效。小团队的沟通成本较低，成员之间可以直接、高效地交换信息，减少了层次间的传递误差。<br>限制团队规模：在实践中，团队的最佳规模是6到10人，这样的团队既能覆盖足够的技能和经验，又能保持较低的沟通成本。在团队规模过大时，最好将其拆分成多个小团队，每个小团队独立工作，并且通过清晰的接口进行协作。</p>
</li>
<li><p>避免不必要的会议：<br>减少会议的数量：虽然会议是信息交流的重要手段，但过多的会议实际上会消耗大量的时间和精力，并可能导致信息的重复传递和无效讨论。程序员们应该将时间更多地投入到编码和问题解决上，而不是长时间的会议中。<br>提高会议效率：如果必须开会，会议应当具有明确的目标和时间限制，参与者应为问题的解决提供实际的贡献。</p>
</li>
<li><p>信息流的管理：<br>使用文档和自动化工具：为了减少直接沟通中的误解和成本，使用文档来规范工作流程和设计，确保所有成员对项目的理解是一致的。同时，使用适当的工具（如版本控制、任务管理工具等）来自动化一些信息传递和任务分配的工作，减少人际沟通中的失误。<br>透明的信息流：在大型团队中，信息流应该尽可能透明，所有相关人员都应该能够访问到项目进展的关键信息。这样可以避免因信息不对称而产生的误解。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/19/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%85%AD%EF%BC%89/" data-id="cm4p9jy3i0008cecae1lbd7m8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-人月神话（五）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/04/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%BA%94%EF%BC%89/" class="article-date">
  <time datetime="2017-02-04T07:21:19.000Z" itemprop="datePublished">2017-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/04/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%BA%94%EF%BC%89/">人月神话（五）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>程序员与其他职业的不同：程序员与其他类型的工人（如工厂工人或普通技术工人）有很大的不同。程序员的工作往往更加依赖于创造性思维和高层次的逻辑推理，而不仅仅是体力劳动或重复性工作。<br>高智力要求：程序员工作需要较强的智力和判断力。一个优秀的程序员不仅仅是编写代码，还要理解复杂的系统，能够对问题进行有效的抽象和解决。</p>
<p>程序员的效率差异：<br>生产力差异：书中提出了一个著名的观点，即不同程序员之间的效率差异非常大。有些程序员可能在一天内完成大量工作，而另一些则可能效率低下。<br>经验和能力：程序员的经验和能力差异是造成这种效率差异的根本原因。富有经验的程序员能够更快地理解需求，设计更高效的解决方案，而新手则可能因为缺乏经验而做出低效的设计和实现。<br>程序员生产力的倍数差异：基于历史数据，不同程序员的生产力差异可能达到10倍甚至更多。因此，招聘有经验的程序员比招聘多个初级程序员要更高效。</p>
<p>程序员的管理与组织：</p>
<ul>
<li>程序员工作不仅仅是操作机器，而是要进行知识性和创造性的劳动。有效的管理应尊重程序员的创造性，避免过度干涉他们的思维方式。</li>
<li>虽然程序员的工作通常是独立的，但在复杂的项目中，团队的协作非常重要。如何让程序员高效合作、减少沟通中的障碍是管理者需要解决的关键问题。</li>
<li>程序员的工作不应仅仅局限于编码，还应包括设计和架构的构建。有效的程序员管理应该鼓励程序员参与到系统设计阶段，而不仅仅是代码实现。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/04/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%BA%94%EF%BC%89/" data-id="cm4p9jy3f0005ceca0tg1hvd1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS 接口与API设计（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/08/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2017-01-07T17:06:11.000Z" itemprop="datePublished">2017-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/08/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/">iOS 接口与API设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>明确接口的目的与目标：<br>设计API时，首先要明确它的目的：API应该解决实际问题，并提供清晰的功能。每个接口和方法应该有一个明确的目标，避免过多不必要的功能混杂。<br>避免设计过于复杂的接口，始终遵循“简单而强大”的原则。</p>
</li>
<li><p>API设计原则：<br>简洁性：API的设计应该尽量简洁，暴露尽可能少的功能。保持接口清晰可以减少错误，便于使用者理解和维护。<br>一致性：设计API时要保持一致的命名规范和行为，避免混乱和不可预测的操作。<br>可扩展性：API应考虑未来的扩展，避免一次设计完成后难以修改。尽量使用可拓展的设计模式，例如插件机制和策略模式等。<br>直观性：API的命名和使用方式应该直观易懂，使得开发者能够轻松理解并且无需查阅过多的文档。</p>
</li>
<li><p>如何定义和命名方法：<br>命名规范：方法的命名要准确描述其功能，同时遵循常见的命名约定（如苹果的命名风格）。避免过长的命名，但又要避免过于模糊。<br>参数顺序：合理安排方法参数的顺序，一般来说，参数顺序应从最关键、最常用的参数开始，逐步到附加参数。<br>避免过度方法重载：API中的方法不要因参数种类过多而重载。过多的重载会导致API的使用者感到困惑。</p>
</li>
<li><p>使用“可选参数”与默认参数：<br>Objective-C不支持命名参数，但可以通过方法签名和默认参数来实现类似效果。<br>如果方法有多个可选参数，可以考虑使用<strong>字典（Dictionary）</strong>来传递参数，这种方式更易扩展，也减少了方法的重载数量。<br>默认值也可以通过设置方法的参数为nil来模拟。</p>
</li>
<li><p>防止不必要的暴露实现细节：<br>尽量保持接口与实现的分离。公开的接口应该尽量简洁且不暴露具体的实现细节。<br>封装：尽量不要暴露类内部的实现结构，尤其是实现数据结构。这有助于以后修改实现而不破坏现有的API使用。</p>
</li>
<li><p>处理错误与异常：<br>返回值：API设计时，要考虑如何返回错误信息。推荐使用NSError对象来处理错误，而不是直接抛出异常，因为Objective-C不具备像Java那样的异常机制。<br>返回类型的设计：返回值类型可以通过nullable和nonnull属性来指示是否可能为空，以帮助开发者避免错误使用。</p>
</li>
<li><p>文档与示例代码：<br>API设计时，文档非常重要。书中建议为每个方法写详细的文档，说明方法的作用、输入输出、可能的错误等。<br>提供实际的示例代码，帮助开发者更好地理解API的使用。</p>
</li>
<li><p>使用协议（Protocol）：<br>协议是Objective-C中设计良好API的关键工具之一。通过协议，可以定义接口并允许不同的类实现这些接口，从而保证了灵活性和可扩展性。<br>如果API需要多个类实现相同的功能，可以通过协议来组织接口，而不是将所有实现放在一个基类中。</p>
</li>
<li><p>避免“写死”的设计：<br>设计API时，不要过于依赖具体的实现或硬编码。可以考虑使用更灵活的机制（如委托、回调等）来降低耦合度，提高代码的可复用性和可测试性。</p>
</li>
<li><p>接口设计中的“协议优先”原则：<br>设计时，尽量优先设计协议而非具体类，协议可以提供更多的灵活性并易于扩展。协议可以允许不同类以相同的方式进行交互，避免不必要的类继承层次。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/08/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="cm4p9jy350000cecagbr8gcr6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-人月神话（四）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/11/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%9B%9B%EF%BC%89/" class="article-date">
  <time datetime="2016-12-11T03:04:42.000Z" itemprop="datePublished">2016-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%9B%9B%EF%BC%89/">人月神话（四）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>“贵族制”和“民主制”。</p>
<p><em>贵族制（Aristocracy）：</em></p>
<p>在贵族制中，决策权集中在少数几个人手中，通常是项目的主设计师或者核心技术人员。这些“贵族”在技术决策、设计和架构上拥有绝对的权威。<br>这种结构下，决策速度较快，因为没有大量的人参与讨论和决策。<br>然而，贵族制的缺点是，如果领导者或者主设计师做出的决定有问题，整个项目就容易受其影响。因为其他成员缺乏足够的参与感，可能无法及时发现和纠正错误。<br>此外，贵族制容易造成知识的集中，团队其他成员的技能提升和参与度较低，可能导致整个团队的创造力受限。</p>
<p><em>民主制（Democracy）：</em></p>
<p>在民主制中，决策权分散到团队中的每个成员，团队成员之间进行广泛的讨论，大家共同参与设计和决策。这种结构倾向于提高团队的协作和参与感。<br>民主制能够充分发挥每个成员的创造力和技术能力，能够更好地发现问题和创新。<br>但民主制也有其缺点。由于决策过程涉及所有成员，决策往往比较缓慢，可能导致无法及时应对技术和项目管理上的变化。此外，团队成员之间的意见分歧也可能导致反复讨论，增加了决策的复杂性。<br>布鲁克斯并不主张完全采纳其中一种形式，而是认为每种方式都有其适用的场景，重要的是根据项目的实际情况，合理选择和组合这两种方式的优点。</p>
<p>系统设计的复杂性往往使得设计过程需要高度的沟通和协作。在大型软件项目中，团队成员的知识和技能差异可能会导致设计方案的不一致。因此，在设计过程中，确保良好的沟通和协调是至关重要的。</p>
<p>团队成员的角色分配应该根据他们的经验和能力来进行，而不是单纯地基于职位或头衔。对于一个项目的成功来说，团队的合作和成员间的沟通比单纯的技术能力更为重要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/11/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%9B%9B%EF%BC%89/" data-id="cm4p9jy3o000gceca2ml2ck7g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-人月神话（三）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/02/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time datetime="2016-12-02T14:29:41.000Z" itemprop="datePublished">2016-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/02/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%B8%89%EF%BC%89/">人月神话（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>该怎么组织一个高效、紧密协作的开发团队呢？</p>
<p>理想情况：团队成员有各自明确的角色，并且每个成员都能专注于自己的职责，整个团队合作无间。</p>
<p>一个关于团队结构和角色分配的重要概念：高效的软件开发团队应当有明确的角色分工，每个成员专注于自己的专业领域，并通过高效的协作完成任务。团队规模不应过大，而应保持在一个合适的范围内，以减少沟通成本和协作难度，团队成员之间需要有紧密的协作和清晰的责任划分，这对于成功的项目管理至关重要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/02/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%B8%89%EF%BC%89/" data-id="cm4p9jy3d0002ceca6oczbpuw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-人月神话（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/27/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2016-11-27T04:13:01.000Z" itemprop="datePublished">2016-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/27/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%BA%8C%EF%BC%89/">人月神话（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>软件工程和其他工程学科（如土木工程、机械工程等）有本质的不同。虽然软件开发的工具和方法变得越来越先进，但其本质依然是非常复杂的。这是因为软件不像其他工程学科那样涉及到物理世界的规律，它更多是基于抽象的概念，难以量化和物理化。</p>
<p>软件工程中的设计、实现、测试和维护都涉及到很多复杂的非线性问题。尤其是当需求不断变化时，开发者很容易陷入“问题沼泽”，难以找到最佳的解决方案。</p>
<p>软件开发的工作不仅仅是单纯的编程和调试，更涉及到人类和机器的密切合作。开发者必须理解和掌控机器（计算机系统）的工作原理，同时也要处理人类团队之间的合作与沟通。</p>
<p>软件开发是一项高度协作的工作，尤其是当项目规模增大时，团队成员之间的协作变得尤为重要。这种协作不仅是技术上的交流，还包括对需求的理解、对项目进度的控制、对问题的解决等方面。</p>
<p>尽管技术是软件开发的核心，但管理也是同样重要的因素。在一个大规模的软件项目中，项目的管理工作与技术工作同样具有挑战性。</p>
<p>很多软件开发项目的失败，并非因为技术问题，而是管理和组织上的问题。特别是当团队规模变得很大时，沟通成本和协作成本显著上升，管理上的挑战变得更加突出。</p>
<p>需求不明确、设计不合理、开发周期过长、版本更新频繁、团队沟通不畅等问题。他指出，这些问题往往源于软件项目的规模和复杂性，而不是技术本身。</p>
<p>“功能蔓延”（feature creep）。这指的是在项目进行过程中，由于需求的不断变化，功能越来越多，项目的复杂性逐渐失控，最终导致项目的延期或失败。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/27/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="cm4p9jy3d0003cecae24g5is4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-人月神话（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/12/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2016-11-12T13:30:10.000Z" itemprop="datePublished">2016-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/12/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%B8%80%EF%BC%89/">人月神话（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>终于翻开了这本软件领域的神作之一《人月神话》，看看大佬怎么解决软件项目管理和开发中遇到的难点。</p>
<p>把软件开发的复杂性和挑战比作通过“沼泽”，就很贴切。尽管软件开发看似简单和富有吸引力，但它却充满了不确定性和难以预见的困难。</p>
<p>软件开发的工作虽然充满创造性和趣味，但也经常让大家感到挫败和无奈。许多程序员可能会遇到需求不明确、功能不断变化、代码质量难以保证等问题，从而使得他们陷入长期的“沼泽”中，无法看到项目的终点。</p>
<p>软件开发并非易事，必须充分理解其复杂性，并以更理性、更深刻的视角来面对和解决其中的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/12/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="cm4p9jy3b0001ceca25wga9qz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS 接口与API设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/16/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2016-10-16T06:01:54.000Z" itemprop="datePublished">2016-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/16/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1/">iOS 接口与API设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在团队开发中，不可避免会将某些代码发布出来供其他同事使用，那么我们在编写接口时就会将其设计成易用复用的形式。需要参考 Objective-C 语言的编程范式，还需要了解各种可能遇到的陷阱。</p>
<p><strong>1. 用前缀避免命名空间冲突</strong><br>OC没有其他语言中内置的命名空间机制，所以我们在命名的时候要设法避免潜在的命名冲突，否则很容易重名。如果发生命名冲突，程序的链接过程就会出错，因为其中出现了重复符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _OBJC_METACLASS_$_MyClass in:</span><br><span class="line">    build/something.o</span><br><span class="line">    build/something._else.o</span><br><span class="line">duplicate symbol _OBJC_CLASS_$_MyClass in:</span><br><span class="line">    build/something.o</span><br><span class="line">    build/something._else.o</span><br></pre></td></tr></table></figure>
<p>错误原因在于，两份代码都各自实现了名为<code>MyClass</code>的类，这导致所对应的类符号和“元类”符号各定义了两次。避免此问题的唯一办法是变相实现命名空间，给所有名称都加上适当的前缀。</p>
<p><strong>2. 提供”全能初始化方法”</strong><br>所有对象都要初始化，在初始化时，有些对象可能无须开发者提供额外信息，但通过来说大部分对象在初始化时候都需要提供某些信息，如果对象不知道必要的信息，则无法完成其工作。<br>比如说，要编写一个学生类。其接口可以这样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface MyStudent: NSObject</span><br><span class="line">@property (nonatomic, copy, readonly) NSString name;</span><br><span class="line">@property (nonatomic, assign, readonly) int age;</span><br><span class="line">@property (nonatomic, assign, readonly) int number;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>我们把属性声明为只读，这样一来，外界就无法设置 MyStudent 对象的属性了。我们可以提供初始化方法以设置这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (MyStudent)initWithName:(NSString *)name age:(int)age andNumber:(int)number&#123;</span><br><span class="line">    if((self = [super init]))&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _age = age;</span><br><span class="line">        _number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 实现 description 方法</strong><br>调试时，经常需要打印并查看对象信息。一种办法是把对象的全部属性都一一输出，但常见的做法还是像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;object = %@&quot;, object);</span><br></pre></td></tr></table></figure>
<p>在构建需要打印到日志的字符串时，<code>object</code>对象会收到<code>description</code>消息，该方法所返回的描述信息将取代“格式字符串”(format string)里的 “%@”。比如说，<code>object</code>是个数组，用下列代码打印其信息时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *object = @[@&quot;A&quot;,&quot;B&quot;];</span><br><span class="line">NSLog(@&quot;object = %@&quot;, object);</span><br></pre></td></tr></table></figure>
<p>则会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = (&quot;A&quot;,&quot;B&quot;)</span><br></pre></td></tr></table></figure>
<p>然而，如果在自定义的类上这么做，那么输出的信息却是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = &lt;MyStudent: 0x7fd9a1600600&gt;</span><br></pre></td></tr></table></figure>
<p>这种日志对我们开发调试没啥帮助，所以我们要在自定义的类里面覆写<code>description</code>方法，输出更有用的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)description&#123;</span><br><span class="line">    return [NSStringstringWithFormat:@&quot;&lt;%@: %p, \&quot;%@ %@ %@\&quot;&gt;&quot;,</span><br><span class="line">            [self class], self, _name,_age,_number];</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 尽量使用不可变对象</strong></p>
<ul>
<li>尽量创建不可变的对象</li>
<li>如果某些属性仅用于对象内部修改，则在”class-continuation 分类”中将其由<code>readonly</code>属性拓展为<code>readwrite</code>属性。</li>
<li>不要把可变的<code>collection</code>作为属性公开，而应该提供相关方法，以此修改对象中的可变<code>collection</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/16/iOS%20%E6%8E%A5%E5%8F%A3%E4%B8%8EAPI%E8%AE%BE%E8%AE%A1/" data-id="cm4p65ael0000fncacdexhrd8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-KVC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/11/KVC/" class="article-date">
  <time datetime="2016-09-11T02:07:19.000Z" itemprop="datePublished">2016-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/11/KVC/">KVC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>KVC 的概念</strong></p>
<p><code>KVC（Key-Value Coding）</code>是<code>Objective-C</code>中的一个强大机制，它允许通过字符串键来访问对象的属性。这种机制使得代码更具灵活性，尤其是在一些动态属性访问场景中，比如在与集合类型的对象（如<code>NSArray</code>、<code>NSDictionary</code>）交互时，或者在实现数据绑定等高级功能时非常有用。</p>
<p><code>KVC</code>的核心思想是通过键值对的方式来访问对象的属性，而不是直接通过<code>getter</code>和<code>setter</code>方法。</p>
<p>KVC在运行时使用动态消息传递的方式来完成这些操作，因此它对代码的灵活性和扩展性非常重要。</p>
<p>KVC常见的使用场景包括：</p>
<ul>
<li>动态修改对象的属性</li>
<li>在集合中查找对象</li>
<li>数据绑定</li>
<li>在某些特殊场景中替代传统的getter&#x2F;setter方法</li>
</ul>
<p><strong>KVC 的工作原理</strong><br><code>KVC</code>通过<code>NSObject</code>类的方法提供属性的动态访问。KVC工作时，调用的是<code>setValue:forKey:</code>和<code>valueForKey:</code>这两个方法。</p>
<ul>
<li><code>valueForKey:</code>：获取某个键（属性）对应的值。</li>
<li><code>setValue:forKey:</code>：设置某个键（属性）对应的值。</li>
</ul>
<p>这些方法会被动态地映射到相应的<code>getter</code>和<code>setter</code>方法，因此我们不需要显式地调用<code>setName:</code>或<code>name</code>这样的<code>getter</code>和<code>setter</code>，而是可以通过键来访问和设置属性值。</p>
<p><strong>KVC 的基本使用</strong></p>
<ol>
<li><p>获取值（valueForKey:）<br>使用<code>valueForKey:</code>方法来访问对象的属性值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *name = [person valueForKey:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>
<p>这里的<code>name</code>是属性的键（通常是属性名）。<code>KVC</code>会根据键查找相应的<code>getter</code>方法，并返回值。</p>
</li>
<li><p>设置值（setValue:forKey:）<br>使用<code>setValue:forKey:</code>方法来修改对象的属性值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person setValue:@&quot;John&quot; forKey:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>
<p>这个方法会调用相应的<code>setter</code>方法来设置<code>name</code>属性。</p>
</li>
<li><p>嵌套键路径<br><code>KVC</code>还支持嵌套键路径，允许你访问对象的嵌套属性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *city = [person valueForKeyPath:@&quot;address.city&quot;];</span><br></pre></td></tr></table></figure>
<p>这里，<code>address</code>是一个<code>Person</code>对象的属性，而<code>city</code>是<code>address</code>属性的属性。<code>KVC</code>会自动递归地解析这个路径并返回对应的值。</p>
</li>
</ol>
<p><strong>KVC 常见的操作</strong></p>
<ol>
<li><p>设置多个属性值（setValuesForKeysWithDictionary:）<br><code>KVC</code>允许你通过字典一次性设置多个属性值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict = @&#123;@&quot;name&quot;: @&quot;John&quot;, @&quot;age&quot;: @30&#125;;</span><br><span class="line">[person setValuesForKeysWithDictionary:dict];</span><br></pre></td></tr></table></figure>
<p>这个方法会将字典中的键值对映射到对象的属性中。</p>
</li>
<li><p>键值验证（validateValue:forKey:）<br><code>KVC</code>允许你在设置值之前对值进行验证。你可以实现<code>validateValue:forKey:</code>方法来确保属性值的合法性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateName:(id *)ioValue error:(NSError **)outError &#123;</span><br><span class="line">    NSString *name = *ioValue;</span><br><span class="line">    if (name.length == 0) &#123;</span><br><span class="line">        if (outError) &#123;</span><br><span class="line">            *outError = [NSError errorWithDomain:@&quot;MyDomain&quot; code:100 userInfo:@&#123;NSLocalizedDescriptionKey: @&quot;Name cannot be empty&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在<code>setValue:forKey:</code>方法调用时会被触发，确保属性值的正确性。</p>
</li>
<li><p>访问数组和字典的元素<br><code>KVC</code>允许你使用键来访问数组和字典中的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&#123;@&quot;name&quot;: @&quot;John&quot;&#125;, @&#123;@&quot;name&quot;: @&quot;Alice&quot;&#125;];</span><br><span class="line">NSString *firstName = [array valueForKeyPath:@&quot;name[0]&quot;];  // 访问第一个元素的&#x27;name&#x27;</span><br></pre></td></tr></table></figure>
<p>你可以使用类似于路径的语法来访问数组或字典中的元素。</p>
</li>
</ol>
<p><strong>KVC的优势和不足</strong><br>优势：</p>
<ul>
<li>动态访问属性：不需要显式地调用<code>getter/setter</code>方法，可以通过键值的方式动态访问。</li>
<li>简化代码：特别是在处理集合对象或复杂的嵌套对象时，<code>KVC</code>可以显著减少代码量。</li>
<li>与集合类型兼容：<code>KVC</code>特别适用于<code>NSArray</code>、<code>NSDictionary</code>等集合类型，可以通过键动态访问集合中的元素或属性。</li>
</ul>
<p>不足：</p>
<ul>
<li>属性必须是<code>KVC</code>兼容的：<code>KVC</code>只能访问遵循<code>KVC</code>约定的属性。这意味着属性需要有对应的<code>getter</code>和<code>setter</code>方法。如果某个属性没有这些方法，<code>KVC</code>将无法访问。</li>
<li>不适用于私有变量：<code>KVC</code>默认只操作公开的属性，无法直接访问私有实例变量。如果想要访问私有变量，可以通过<code>valueForKey:</code>来实现，但是需要手动为这些变量提供相应的<code>getter</code>和<code>setter</code>。</li>
<li>动态类型限制：<code>KVC</code>通过动态消息传递机制实现属性的访问，所以如果你在访问过程中修改了对象的结构（比如在运行时移除或添加某些属性），<code>KVC</code>可能会导致不稳定的行为。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/11/KVC/" data-id="cm4p4n62l00007kca6oas4t38" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-KVO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/07/KVO/" class="article-date">
  <time datetime="2016-08-07T13:27:32.000Z" itemprop="datePublished">2016-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/07/KVO/">KVO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>KVO 的概念</strong><br>KVO（Key-Value Observing）是 iOS 开发中一个强大的机制，允许对象观察其他对象的属性变化。在实现数据绑定、视图更新和响应数据变化时非常有用。</p>
<p>KVO是一种基于观察者模式的机制，它允许对象观察某个属性的变化，并在变化时收到通知。被观察的属性必须是KVC（Key-Value Coding）兼容的，这意味着属性需要通过键值访问。<br><strong>KVO 的工作原理</strong><br>当你为一个对象的属性注册为观察者时，iOS底层会动态地生成一个对象的子类（通过Objective-C运行时），并重写属性的setter方法。这个setter方法会在属性发生变化时通知所有的观察者。</p>
<p>观察者通过以下方法接收变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath </span><br><span class="line">                      ofObject:(id)object </span><br><span class="line">                        change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change </span><br><span class="line">                       context:(void *)context;</span><br></pre></td></tr></table></figure>

<p><strong>KVO 的使用步骤</strong></p>
<ol>
<li>添加观察者<br>使用addObserver:forKeyPath:options:context:方法为某个对象的属性添加观察者。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self </span><br><span class="line">              forKeyPath:@&quot;name&quot; </span><br><span class="line">                 options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld </span><br><span class="line">                 context:nil];</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>observer：观察者对象。</li>
<li>keyPath：需要观察的属性路径。</li>
<li>options：指定需要的变化信息（如新值、旧值等）。</li>
<li>context：上下文指针，可以传递额外的信息。</li>
</ul>
<ol start="2">
<li>实现回调方法<br>当被观察属性的值变化时，observeValueForKeyPath:ofObject:change:context:方法会被调用：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath </span><br><span class="line">                      ofObject:(id)object </span><br><span class="line">                        change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change </span><br><span class="line">                       context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;旧值: %@, 新值: %@&quot;, change[NSKeyValueChangeOldKey], change[NSKeyValueChangeNewKey]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>移除观察者<br>在不需要观察时，记得移除观察者，避免内存泄漏或崩溃：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>常见KVO选项</li>
</ol>
<ul>
<li><code>NSKeyValueObservingOptionNew：</code> 回调中包含新值。</li>
<li><code>NSKeyValueObservingOptionOld：</code> 回调中包含旧值。</li>
<li><code>NSKeyValueObservingOptionInitial：</code> 立即收到初始值的通知。</li>
<li><code>NSKeyValueObservingOptionPrior：</code> 在值变化前后都会收到通知。</li>
</ul>
<p><strong>注意事项和最佳实践</strong></p>
<ol>
<li>移除观察者</li>
</ol>
<ul>
<li>在对象释放之前，必须移除所有观察者，否则会导致崩溃。</li>
<li>在<code>dealloc</code>中确保移除所有观察者。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>避免重复添加观察者</li>
</ol>
<ul>
<li>重复添加观察者会导致多次回调，容易引发bug。</li>
</ul>
<ol start="3">
<li>线程安全</li>
</ol>
<ul>
<li>如果被观察的属性在多线程环境下被修改，可能会导致不一致或崩溃。可以使用同步锁或<code>@synchronized</code>确保线程安全。</li>
</ul>
<ol start="4">
<li>只能观察KVC兼容属性</li>
</ol>
<ul>
<li>直接使用<code>@property</code>声明的属性是<code>KVC</code>兼容的，动态添加的变量（如ivar）不支持<code>KVO</code>。</li>
</ul>
<ol start="5">
<li>使用上下文来区分观察者</li>
</ol>
<ul>
<li>如果同一个类中观察了多个属性，可以使用<code>context</code>参数区分不同的观察。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void *NameContext = &amp;NameContext;</span><br><span class="line"></span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:... context:NameContext];</span><br></pre></td></tr></table></figure>
<p>在回调中检查上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (context == NameContext) &#123;</span><br><span class="line">    // 处理 name 的变化</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>KVO的局限性</li>
</ol>
<ul>
<li>容易出错：忘记移除观察者可能导致崩溃。</li>
<li>调试困难：错误可能隐藏在底层动态生成的代码中。</li>
<li>性能问题：KVO在观察大量属性时可能导致性能下降。</li>
<li>代码复杂性：对复杂属性依赖的观察管理不便。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/07/KVO/" data-id="cm4p2kc2t0000wocaawe0c26n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/10/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/">人月神话（十六）</a>
          </li>
        
          <li>
            <a href="/2017/08/15/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/">人月神话（十五）</a>
          </li>
        
          <li>
            <a href="/2017/07/16/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/">人月神话（十四）</a>
          </li>
        
          <li>
            <a href="/2017/06/11/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/">人月神话（十三）</a>
          </li>
        
          <li>
            <a href="/2017/05/27/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/">人月神话（十二）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Yunxin Bai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>